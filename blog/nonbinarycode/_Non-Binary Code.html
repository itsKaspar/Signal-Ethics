Specifying C++ or Python as spoken languages next to English, French, Spanish has become a common practice both in the redaction
of Curriculum Vitaes and dating app profiles. Letting other people know that one speaks a specific programming language has become a way
of identifying oneself to a certain group of digital literacy, often transcending the paradigms of the language itself to a broader
aspect of internet culture, and ability to understand its underlying mechanisms.

Yet programming languages themselves aren't designed for human to human communication, historically their story begins as a set of instructions
written by a human to be executed by a machine. First and foremost code is written, and it's redaction inside a file holds the intention of
writting a program or a script designed to be a set of instructions to be executed by a computer.

These programs, made of code, hold a specific
both understandable by humans, and readable by machines, just as in [doublespeak](https://en.wikipedia.org/wiki/Doublespeak)

They act as a interface

Programming languages are often the work
school of rational thinking, syntax and vocabulary close to english, code written left to right
it isn't just a surfacial and within, as within the internal logic holds a heritage of protestant ethics, a manichean vision of the world
as good and evil, as true and false. At least in appearance.

In this first volume of Non-Binary Code Studies, we'll be focusing our attention on the Javascript language and it's undefined state/value


## Statements & Expressions

What is a statement

In computer science an expression is a combination of symbols that can be evaluated to determine its value.
A common expression example is : 2 + 2. This is what we call an **arithmetic expression** as it involves a calculation between numbers
which implies a numerical result. Since 2 + 2 = 4, the following expression will be evaluated to 4.

Using a code interpreter we can evaluate the expression programmatically :

```js
> 2 + 2
4
```

Another common type of expression is the **relational expression** which studies an expression in relationship to another.
Just as arithmetic expressions use the well known symbols for addition (+), subtraction (-),..
relational expression uses it's own set of symbols as follows :

| symbol  | definition              |
| --      | :-----------            |
| ==      | is equal to             |
| ===     | is strictly equal to    |   
| >       | is superior than        |  
| <       | is inferior than        |  
| >=      | is superior or equal to |
| <=      | is inferior or equal to |

Using these symbols we can programmatically evaluate some trivial expression such as "two is superior to one" or "two is equal to one"

```js
> 2 > 1
true

> 2 == 1
false
```

Evaluating a relational expression typically results in either of these two states : true or false.
These states are called booleans, and reference what is called [boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra),
in contrast to elementary alegebra which uses the range of all numbers, boolean algebra consists of only two elements.

>>>>multi valued logic(such as fuzzy logic and relevance logic)

As such, there is no nuance to truth values, no degree of truth-ness
As such it is inscribed in the ideology of modern programming ethics
that there is no nuance to truth, that a relational expression allows solely two states, whom sit opposed to one another.
the state of true and the state of false which, which unrespectively can be used to validate or invalidate any other ramifications throughout a program

Wether something is true or false, follows a school of thought inherited from rational thinking and mathematics


## The undefined state

Yet there exists a third expression evaluation called undefined.
Which is neither true nor false, it is simply undefined and equal to itself.

```js
> undefined
undefined

> undefined == true
false

> undefined == false
false

> undefined == undefined
true
```

It's behavior seems logical

The act of assigning a value to a variable, is itself undefined

```js
> let a = 1
undefined
```

Yet the oddities begins here,
Semantically undefined can mean :
1. Something without a definition
2. Something that has been stripped from it's definition

Undefined is it's own value, and is not the contrary of a defined variable

```js
> let a = undefined
undefined // assigning a variable = undefined

> a
undefined

> b
Uncaught ReferenceError: b is not defined
```

Now let us test our second case

```js
> let a = 1
undefined // assigning a variable = undefined

> delete(a)
true // the delete operation returns true when successful

> a
Uncaught ReferenceError: a is not defined
```

In both of our cases there is a clear difference between a value that was not defined (or stripped from it's definition) and the undefined state.
Which means that undefined is something else entirely than what semantics suggest
Let us then consider two different states, the undefined state which exists, and the 'not defined' state which throws an error

```js
> !undefined
true

> !!undefined
false
```

## The Null

```js
> undefined == null
true

> undefined === null
false
```

```js
> Number(undefined)
NaN

> Number(null)
0
```

## The undefined state

The language paradigms of programming thought schools, a superficial world of binary values which in turn is converted a decimal system on the contrary to shrodinger's
 cat an undefined state is not a state that is given a definition when it is called (say something clever of deeper understanding of shrodingers cat) What possible values for a variable ?
 true or false (the ultimate binary statement) every statement can be interpreted as a boolean but booleans can also be undefined Of the nature of numbers integers decimal points
  Infinity and -Infinity NaN Pushing a spectrum of true/false logic something can be somewhat true, somewhat false somewhat undefined, somewhat NaN

## Towards a spectrum of state

```js
> 2 + 2
4
```
